import {useEffect, useRef, useState} from 'react';
import Image from "next/image";
import {cc} from "../common/variables";
import {type} from "os";
import {Container} from "postcss";
const layoutGeometry = require('../libs/justified-layout_v2');

//NOTE: Script *will* cause a crash if the container is too small for images to exist at all. Need to fix this.

function MyImageGallery(galleryInput) {
    checkInputForErrors(galleryInput);

    const galleryElementRef = useRef(null);
    const [ imageElements, setImageElements ] = useState(null);

    const galleryInputWithDefaults = addDefaultsToGalleryInput(galleryInput);
    const { containerPadding, containerWidth } = {...galleryInputWithDefaults};
    const njGalleryStyle = createGalleryStyle(containerPadding, containerWidth);

    galleryResizeHook(setImageElements, galleryInputWithDefaults, galleryElementRef);

    return (
            <div className={"njGallery"}
                style={njGalleryStyle}
                ref={galleryElementRef}
            >
                {imageElements}
            </div>
    );
}


function createGalleryLayout(galleryInputWithDefaults, galleryElementRef){
    const galleryInputCopy = {...galleryInputWithDefaults}
    const {images, imagePadding} = galleryInputCopy;
    const imageLayout = calculateGalleryLayout(galleryInputCopy, galleryElementRef);
    const reformattedImageData = reformatGalleryData(imageLayout, images);

    return reformattedImageData.map((e, k) => {
        e.height = Math.trunc(+e.boxHeight);
        e.width = Math.trunc(+e.boxWidth);

        return (
            <div
                style={{ "margin": (imagePadding.vertical/2) + "px " + (imagePadding.horizontal/2) + "px " + (imagePadding.vertical/2) + "px " + (imagePadding.horizontal/2) + "px", }}
                key={k}
            >
                <Image
                    src={e.imgSrc}
                    blurDataURL={e.imgBlurSrc}
                    placeholder={e.imgBlurSrc && "blur"}
                    className={"njGalleryImage"}
                    width={e.boxWidth}
                    height={e.boxHeight}
                    alt={e.alt}
                />
            </div>
        );
    });
}

function calculateGalleryLayout(galleryInputCopy, galleryElementRef){
    const { images, containerPadding, targetRowHeight, imagePadding, maxRows, showIncompleteRows, targetRowHeightTolerance } = galleryInputCopy;

    const imageDimensions = images.map((e) => {
        return {width: e.width, height: e.height}
    });

    const elementMinimumPadding = containerPadding;
    let galleryElementWidth;
    galleryElementRef?.current?.offsetWidth ? galleryElementWidth = galleryElementRef?.current?.offsetWidth-4 : galleryElementWidth = 14; // -4 because otherwise at some widths, the last image in a row jumps to the next row. Total width might be e.g. 0.42 pixels too large.
    if ((galleryElementWidth - elementMinimumPadding) < 14) galleryElementWidth = 14 + elementMinimumPadding;

    const autoGeneratedWidth = Math.trunc(galleryElementWidth);
    const imageLayout = layoutGeometry(imageDimensions, {
            containerWidth: autoGeneratedWidth,
            targetRowHeight: targetRowHeight || 300,
            containerPadding: containerPadding,
            boxSpacing: imagePadding,
            maxNumRows: maxRows,
            showWidows: showIncompleteRows,
            targetRowHeightTolerance: targetRowHeightTolerance,
            edgeCaseMinRowHeight: 80,
        }
    );

    return imageLayout;
}

function reformatGalleryData(imageLayout, images){
    const imagesCopy = [...images];
    let reformattedImageData = [];

    for (let i = 0; i < imageLayout.boxes.length; i++){
        reformattedImageData[i] = {};
        reformattedImageData[i].boxHeight = imageLayout.boxes[i].height;
        reformattedImageData[i].boxWidth = imageLayout.boxes[i].width;
        reformattedImageData[i].imgSrc = imagesCopy[i].src;
        reformattedImageData[i].imgBlurSrc = imagesCopy[i].blurSrc;
        reformattedImageData[i].alt = imagesCopy[i].alt;
    }

    return reformattedImageData;
}

function checkInputForErrors(galleryInput){
    const galleryInputCopy = {...galleryInput}
    const {images, containerWidth, containerPadding, imagePadding, targetRowHeight, targetRowHeightTolerance, showIncompleteRows } = galleryInputCopy;

    if (!images) throw new Error("You must include images.");
    for (let entry of images){
        if (!entry.src) throw new Error("Every image must include a source (URL).");
        if (!entry.width) throw new Error("Every image must include a width value.");
        if (!entry.height) throw new Error("Every image must include a height value.");
        if (typeof entry.width !== "number") throw new Error("Image width must be a number, not a string.");
        if (typeof entry.height !== "number") throw new Error("Image height must be a number, not a string.");
    }

    if (targetRowHeightTolerance && targetRowHeightTolerance > 1 || targetRowHeightTolerance < 0 || typeof targetRowHeightTolerance !== "number") throw new Error("targetRowHeightTolerance must be a number between 0 and 1.");
    if (containerPadding && containerPadding % 2 !== 0) throw new Error("Container padding must be an even number.");
    if (targetRowHeight && typeof targetRowHeight !== "number") throw new Error("Target row height must be a number.");
    if (targetRowHeight && typeof targetRowHeight === "number" && targetRowHeight < 10) throw new Error("Target row height must be a positive number, and greater than 10.");
    if (showIncompleteRows && typeof showIncompleteRows !== "boolean") throw new Error("Show Incomplete Rows must be boolean (true or false)");

    checkPaddingsForErrors(containerPadding, "Container");
    checkPaddingsForErrors(imagePadding?.vertical, "Image vertical");
    checkPaddingsForErrors(imagePadding?.horizontal, "Image horizontal");

    function checkPaddingsForErrors(element, elementName){
        if (element && typeof element !== "number") throw new Error(`${elementName} padding must be a number.`);
        if (element && typeof element === "number" && element < 0) throw new Error(`${elementName} padding must be a positive number.`);
    }
}


function addDefaultsToGalleryInput(galleryInput){
    const galleryInputCopy = {...galleryInput}
    const defaults = {
        images: galleryInputCopy.images,
        containerPadding: galleryInputCopy.containerPadding || 10,
        containerWidth: galleryInputCopy.containerWidth || "100%",
        targetRowHeight: galleryInputCopy.targetRowHeight || 300,
        justifyFinalRow: galleryInputCopy.justifyFinalRow || false,
        imagePadding: galleryInputCopy.imagePadding || {vertical: 10, horizontal: 10},
        maxRows: galleryInputCopy.maxRows || Number.POSITIVE_INFINITY,
        showIncompleteRows: (galleryInputCopy.showIncompleteRows === false ? false : true),
        targetRowHeightTolerance: galleryInputCopy.targetRowHeightTolerance || 0.25,
    }

    return Object.assign(galleryInputCopy, defaults);
}

function galleryResizeHook(setGalleryElements, galleryInputWithDefaults, galleryElementRef){
    useEffect(() => {
        setGalleryElements(createGalleryLayout(galleryInputWithDefaults, galleryElementRef));

        window.addEventListener('resize', () => setGalleryElements(createGalleryLayout(galleryInputWithDefaults, galleryElementRef)));
        return () => {
            window.removeEventListener('resize', () => setGalleryElements(createGalleryLayout(galleryInputWithDefaults, galleryElementRef)));
        }
    }, []);
}

function createGalleryStyle(containerPadding, containerWidth){
    return {
        "width": (containerWidth),
        "display": "flex",
        "flexWrap": "wrap",
        "padding": (containerPadding/2) + "px " + (containerPadding/2) + "px " + (containerPadding/2) + "px " + (containerPadding/2) + "px",
    }
}

export default MyImageGallery;